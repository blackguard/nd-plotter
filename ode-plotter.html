<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
<!--

MIT License

Copyright (c) 2022 Ed Puckett

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

-->
    <script src="https://cdn.plot.ly/plotly-2.8.3.min.js"></script>
    <style>
        #input {
            width: 100%;
        }
        #controls div * {
            vertical-align: middle;
        }
        .display {
            margin-left: 0.1rem;
            padding: 0 0.5rem;
            background-color: #eee;
        }
    </style>
</head>
<body>
    <textarea id="input">
// F = (number[], params?: any) => number[]
//
// PointCloud = {
//     n: integer,
//     c: number[];
//     r: number,
//     dt?: number,
//     steps?: integer,
// }
//
// Config = {
//     extrapolator?: (dt: number, f: F, x: number[], params: any),
//     dt?: number,
//     x0?: number[],
//     params?: any,
//     skip?:  integer,
//     steps?: integer,
//     point_cloud?: PointCloud,
// }
//
// EquationDef = Config + {
//     iter?: iterable<Config>|generator<Config>(def: EquationDef),
//     iter_delay?: number,
//     f: F,
// }


// extrapolator:
// f(x) returns xdot which has the same dimension as x
// extrapolator returns a new x with the same dimension as the original

function runge_kutta_extrapolator(dt, f, x, params) {
    // This is an implementation of the fourth-order Runge-Kutta method
    // as presented in Nonlinear Dynamics and Chaos, Second Edition, by
    // Steven H. Strogatz, page 34.
    // This implementation works for x with arbitrary dimension.
    const k1 = f( x,                                params ).map( xidot => xidot*dt );
    const k2 = f( x.map( (xi, i) => xi + k1[i]/2 ), params ).map( xidot => xidot*dt );
    const k3 = f( x.map( (xi, i) => xi + k2[i]/2 ), params ).map( xidot => xidot*dt );
    const k4 = f( x.map( (xi, i) => xi + k3[i]),    params ).map( xidot => xidot*dt );
    return x.map( (xi, i) => xi + (k1[i] + 2*k2[i] + 2*k3[i] + k4[i])/6 );
}


// Definitions for some chaotic attractors provided by Dr. James P. Crutchfield
// (one of the pioneers of Chaos Theory).
//
// For more information on chaotic attractors see Lecture 3 on the Roadmap page at the course:
//
//                 http://csc.ucdavis.edu/~chaos/courses/poci/

const extrapolator = runge_kutta_extrapolator;

const lorenz_def = {
    extrapolator,
    dt: 0.005,
    x0: [3, 3, 1],
    f:  ( (sigma=10, r=28, b=8/3) =>
          ([x, y, z]) => [  // this is f, and it takes 1 argument which is decomposed into [x, y, z]
              sigma*(y - x),
              r*x - y - x*z,
              x*y - b*z,
          ]
        )()
};

const owl_def = {
    extrapolator,
    dt: 0.005,
    x0: [3, 3, 1],
    f:  ( (a=10, b=10, c=13) =>
          ([x, y, z]) => [
              -a*(x + y),
              -y - b*x*z,
              10*x*y + c,
          ]
        )()
};

const rossler_def = {
    extrapolator,
    dt: 0.008,
    x0: [10, 10, 1],
    f:  ( (a=0.2, b=0.2, c=5.7) =>
         ([x, y, z]) => [
             -y - z,
             x + a*y,
             b + z*(x - c),
         ]
        )()
};

const rikitake0_def = {  // see: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7517210/
    extrapolator,
    dt: 0.01,
    x0: [3, 1, 6],
    f:  ( (alpha=5, beta=2) =>
          ([x, y, z]) => [
              -beta*x + y*z,
              -beta*y - alpha*x + x*z,
              1 - x*y,
          ]
        )()
};

const rikitake_def = {
    extrapolator,
    dt: 0.009,
    x0: [0.268, 2, 0],
    f:  ( (a=1, b=3.75) =>
          ([x, y, z]) => [
              -a*x + z*y,
              -a*y - (z - b)*x,
              1 - x*y,
          ]
        )()
};

const hyperchaos_def = {
    extrapolator,
    dt: 0.005,
    x0: [-20, 15, 0, 35],
    f:  ( (a=0.25, b=-0.5, c=2.2, d=0.05) =>
          ([x, y, z, w]) => [
              -y - z,
              x + a*y + w,
              c + x*z,
              b*z + d*w,
          ]
        )()
};

const point_cloud_def = {
    extrapolator,
    dt: 0.005,
    x0: [3, 3, 1],
    params: { sigma: 10, r: 28, b: 8/3 },
    f:  ([x, y, z], {sigma, r, b}) => [
             sigma*(y - x),
             r*x - y - x*z,
             x*y - b*z,
        ],
    skip:  1000,
    steps: 10000,
    point_cloud: {
        n: 6000,
        c: [3, 3, 1],
        r: 0.05,
        dt: 0.05,
    }
};

// return the equation definition to plot
return point_cloud_def;
    </textarea>
    <div id="controls">
        <div>
            <button id="go">Go</button>
        </div>
        <div>
            <label for="points_per_loop">Time steps per loop</label>
            <input id="points_per_loop" type="range" min="1" max= "10000" value="1000">
            <span id="points_per_loop_display" class="display"></span>
        </div>
        <div>
            <label for="loop_delay">Loop delay</label>
            <input id="loop_delay" type="range" min="0" max= "500" value="50">
            <span id="loop_delay_display" class="display"></span> ms
        </div>
        <div>
            <label for="points_shown">Time steps shown</label>
            <input id="points_shown" type="range" min="0" max="100000" step="10" value="20000">
            <span id="points_shown_display" class="display"></span>
        </div>
        <div>
            <label for="point_count_display">Total time steps</label>
            <span id="point_count_display" class="display"></span>
        </div>
    </div>
    <div id="plot"></div>
    <div id="output"></div>

    <script>
        const input_el  = document.getElementById('input');
        const plot_el   = document.getElementById('plot');
        const output_el = document.getElementById('output');

        const go_button = document.getElementById('go');

        const points_per_loop_el     = document.getElementById('points_per_loop');
        const loop_delay_el          = document.getElementById('loop_delay');
        const points_shown_el        = document.getElementById('points_shown');
        const point_count_display_el = document.getElementById('point_count_display');

        for (const range_id of [
            'points_per_loop',
            'loop_delay',
            'points_shown',
        ]) {
            const range_el   = document.getElementById(range_id);
            const display_el = document.getElementById(`${range_id}_display`);
            display_el.innerText = range_el.value;
            range_el.addEventListener('input', (event) => {
                display_el.innerText = range_el.value;
            });
        }

        function setup_auto_resize(textarea) {
            const initial_height = (textarea.scrollHeight > 0) ? `${textarea.scrollHeight}px` : '0.5em';
            textarea.setAttribute('style', `height:${initial_height}; overflow-y:hidden;`);
            textarea.addEventListener("input", function textarea_input_handler(event) {
                const textarea = event.target.closest('textarea');
                const cs = window.getComputedStyle(textarea);
                // note: all cs dimensional values are floating-point values followed by 'px'
                const paddingY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
                textarea.style.height = `${textarea.scrollHeight - paddingY}px`;
            });
        }
        setup_auto_resize(input_el);
        input_el.addEventListener('change', function (event) {
            // update innerHTML so that saving the page saves changes, too
            input_el.innerHTML = input_el.value;
        });

        const plot_height = 720;
        plot_el.style = `height: ${plot_height}px`;

        const Generator = Object.getPrototypeOf(function*(){}).constructor;

        function validate_f(f) {
            if (typeof f !== 'function') {
                throw new Error('f must be a function');
            }
        }
        function validate_extrapolator(extrapolator) {
            if (typeof extrapolator !== 'function') {
                throw new Error('extrapolator must be a function');
            }
        }
        function validate_point_cloud(point_cloud) {
            if ( typeof point_cloud !== 'object') {
                throw new Error('point_cloud must be an object')
            }
            const { n, c, r, dt, steps } = point_cloud;
            if (typeof n === 'undefined') {
                throw new Error('point_cloud.n must be defined');
            } else if (!Number.isInteger(n) || n <= 0) {
                throw new Error('point_cloud.n must be a positive integer');
            }
            if (typeof c === 'undefined') {
                throw new Error('point_cloud.c must be defined');
            } else if (!Array.isArray(c) || c.length <= 0 || c.some(e => (typeof e !== 'number'))) {
                throw new Error(`point_cloud.c must be a non-empty array of numbers`);
            }
            if (typeof r === 'undefined') {
                throw new Error('point_cloud.r must be defined');
            } else if (typeof r !== 'number' || r <= 0) {
                throw new Error('point_cloud.r must be a positive number');
            }
            if (typeof dt !== 'undefined' && (typeof dt !== 'number' || dt <= 0)) {
                throw new Error(`point_cloud.dt must be a positive number`);
            }
            if (typeof steps !== 'undefined' && (!Number.isInteger(steps) || steps < 0)) {
                throw new Error('steps point_cloudmust be a non-negative integer');
            }
        }
        function validate_config(config, structure_name='config') {
            if ( typeof config !== 'object') {
                throw new Error(`${structure_name} must be an object`)
            }
            const { extrapolator, dt, x0, skip, steps, point_cloud } = config;  // params is unrestricted
            if (extrapolator) {
                validate_extrapolator(extrapolator);
            }
            if (typeof dt !== 'undefined' && (typeof dt !== 'number' || dt <= 0)) {
                throw new Error(`${structure_name}.dt must be a positive number`);
            }
            if (typeof x0 !== 'undefined' &&
                 (!Array.isArray(x0) || x0.length <= 0 || x0.some(e => (typeof e !== 'number'))) ) {
                throw new Error(`${structure_name}.x0 must be a non-empty array of numbers`);
            }
            if (typeof skip !== 'undefined' && (!Number.isInteger(skip) || skip < 0)) {
                throw new Error(`${structure_name}.skip must be a non-negative integer`);
            }
            if (typeof steps !== 'undefined' && (!Number.isInteger(steps) || steps < 0)) {
                throw new Error(`${structure_name}.steps must be a non-negative integer`);
            }
            if (point_cloud) {
                validate_point_cloud(point_cloud);
            }
        }
        function validate_equation_def(equation_def) {
            if ( typeof equation_def !== 'object') {
                throw new Error('equation definition must be an object')
            }
            validate_config(equation_def, 'equation_def');  // equation_def is a subclass of config
            const { iter, iter_delay, f } = equation_def;
            if (iter) {
                const iterator_fn = iter[Symbol.iterator];
                if ( (typeof iterator_fn !== 'undefined' && typeof iterator_fn !== 'function') &&
                     !(iter instanceof Generator) ) {
                    throw new Error('equation_def.iter must be an iterable or a generator function');
                }
            }
            if (typeof iter_delay !== 'undefined' && (typeof iter_delay !== 'number' || iter_delay < 0)) {
                throw new Error('equation_def.iter_delay must be a non-negative number');
            }
            if (typeof f === 'undefined') {
                throw new Error('equation_def.f must be defined');
            } else {
                validate_f(f);
            }
        }

        let runner;
        function set_running_state(running) {
            runner?.stop();
            if (running) {
                const new_runner = new Runner(input_el.value);
                runner = new_runner;
                new_runner.done.then(
                    () => {
                        if (!new_runner.stopped) {
                            set_running_state(false);
                        }
                    },
                    error => {
                        if (!new_runner.stopped) {
                            set_running_state(false);
                        }
                    }
                );
                point_count_display_el.innerText = '';
                go_button.innerText = 'Stop';
                go_button.scrollIntoView();
            } else {
                runner = undefined;
                go_button.innerText = 'Go';
            }
        }
        go_button.addEventListener('click', async (event) => {
            set_running_state(!runner);
        });

        class Runner {
            constructor(input_expression) {
                this._input_expression = input_expression;

                this._xs = [];
                this._ys = [];
                this._zs = [];
                this._cs = [];

                this._gdata = [{
                    type: 'scatter3d',
                    mode: 'lines',
                    x: this._xs,
                    y: this._ys,
                    z: this._zs,
                    opacity: 1,
                    line: {
                        width: 3,
                        color: this._cs,
                        reversescale: false,
                    },
                }];

                this._paused = false;

                this._the_plot_el_mousedown_handler = (event) => { this._paused = true; };
                this._the_plot_el_mousedown_handler_options = { capture: true };
                this._the_plot_el_mouseup_handler = (event) => { this._paused = false; };
                this._the_plot_el_mouseup_handler_options = { capture: true };
                plot_el.addEventListener(
                    'mousedown',
                    this._the_plot_el_mousedown_handler,
                    this._the_plot_el_mousedown_handler_options
                );
                plot_el.addEventListener(
                    'mouseup',
                    this._the_plot_el_mouseup_handler,
                    this._the_plot_el_mouseup_handler_options
                );

                this._stopped = false;
                this._running = false;

                this._done = new Promise(async (resolve, reject) => {
                    this._running = true;
                    try {

                        const equation_def = await this.constructor._evaluate(this._input_expression);
                        validate_equation_def(equation_def);

                        const { f, iter_delay } = equation_def;
                        let   { iter }          = equation_def;

                        if (!iter) {
                            iter = [{}];  // one empty config
                        } else if (iter instanceof Generator) {
                            iter = iter(equation_def);
                        }
                        // iter is now an iterable

                        let first_iteration = true;
                        for (const config of iter) {
                            if (!this._running) {
                                break;
                            }

                            this._clear_data();

                            const merged_config = {
                                ...equation_def,  // equation_def may contain config properties
                                ...config,        // config properties override those in equation_def
                            };
                            validate_config(merged_config);

                            if (iter_delay && !first_iteration) {
                                await new Promise(resolve => setTimeout(resolve, iter_delay));
                            }
                            first_iteration = false;

                            const { extrapolator, dt, x0, params, skip=0, steps=Infinity, point_cloud } = merged_config;

                            let x = [ ...x0 ];  // copy x0 to insulate from mutation
                            if (skip <= 0) {
                                this._add(x);
                            }

                            let plot_fn = Plotly.newPlot;
                            let point_count = 0;
                            while (this._running && point_count < skip+steps) {
                                if (!this._paused) {
                                    const points_per_loop = parseInt(points_per_loop_el.value);
                                    for (let lp = 0; lp < points_per_loop; lp++) {
                                        if (!this._running) {
                                            break;
                                        }
                                        x = extrapolator(dt, f, x, params);
                                        point_count++;
                                        if (point_count >= skip) {
                                            this._add(x);
                                        }
                                        if (point_count >= skip+steps) {
                                            break;
                                        }
                                    }

                                    this._trim_data();

                                    if (point_count >= skip) {
                                        this._draw_data(plot_fn);
                                        plot_fn = Plotly.react;
                                    }

                                    point_count_display_el.innerText = point_count;
                                }

                                if (point_count < skip+steps) {
                                    const loop_delay = parseInt(loop_delay_el.value);
                                    await new Promise(resolve => setTimeout(resolve, loop_delay));
                                }
                            }

                            // Done plotting graph for this config.
                            // Finally, run its point cloud, if any.
                            if (point_cloud) {
                                await this._run_point_cloud(f, merged_config);
                            }
                        }

                        // done
                        resolve();

                    } catch (err) {
                        console.error(err.message, err.stack);
                        alert(`${err.message}\n\n${err.stack}`);
                        reject(err);
                    }
                });
            }

            get running (){ return this._running; }
            get paused  (){ return this._paused;  }
            get stopped (){ return this._stopped; }
            get done    (){ return this._done;    }

            stop() {
                this._stopped = true;
                this._running = false;
                plot_el.removeEventListener(
                    'mousedown',
                    this._the_plot_el_mousedown_handler,
                    this._the_plot_el_mousedown_handler_options
                );
                plot_el.removeEventListener(
                    'mouseup',
                    this._the_plot_el_mouseup_handler,
                    this._the_plot_el_mouseup_handler_options
                );
            }

            // internal

            _clear_data() {
                this._xs.splice(0, this._xs.length);
                this._ys.splice(0, this._ys.length);
                this._zs.splice(0, this._zs.length);
                this._cs.splice(0, this._cs.length);
            }

            _trim_data() {
                let limit = parseInt(points_shown_el.value);
                if (isNaN(limit)) {
                    limit = 0;
                }
                if (this._xs.length > limit) {
                    this._xs.splice(0, this._xs.length-limit);
                    this._ys.splice(0, this._ys.length-limit);
                    this._zs.splice(0, this._zs.length-limit);
                    this._cs.splice(0, this._cs.length-limit);
                }
            }

            _add([x, y, z], c=1) {
                this._xs.push(x ?? 0);
                this._ys.push(y ?? 0);
                this._zs.push(z ?? 0);
                this._cs.push(c);
            }

            _draw_data(plot_fn) {
                const layout = {
                    height: plot_height,
                    datarevision: Date.now(),
                };
                // note: plot_el._fullLayout is undocumented...
                if (plot_el._fullLayout?.scene?.camera) {
                    layout.scene = {
                        camera: plot_el._fullLayout.scene.camera,
                    };
                }
                plot_fn(plot_el, this._gdata, layout);
            }

            async _run_point_cloud(f, config) {
                // config contains point_cloud
                // assume config has already been validated
                if (!this._gdata) {
                    throw new Error('unexpected: !this._gdata');
                }
                // push a new trace for the point cloud onto the data
                const pc_trace = {
                    type: 'scatter3d',
                    mode: 'markers',
                    marker: {
                        color: 'rgba(0, 0, 255, 1.0)',
                        size: 1,
                    },
                };
                this._gdata.push(pc_trace);  // add the new trace to the data

                const { extrapolator, dt, x0, params, point_cloud } = config;
                const { n, c, r, dt:pc_dt=dt, steps=Infinity } = point_cloud;

                let points = [];
                function update_trace() {
                    pc_trace.x = points.map(x => (x[0] ?? 0));
                    pc_trace.y = points.map(x => (x[1] ?? 0));
                    pc_trace.z = points.map(x => (x[2] ?? 0));
                }

                // generate the initial positions of the points
                // the points we generate here lie in a N-cube centered at c
                // with side length 2*r (where N = c.length).
                for (let i = 0; i < n; i++) {
                    points.push( c.map(xi => xi + r*2*(Math.random() - 0.5)) );
                }
                update_trace();

                main_loop:
                for (let s = 0; s < steps; s++) {
                    while (this._paused && this._running) {
                        await new Promise(resolve => setTimeout(resolve), 100);
                    }
                    if (!this._running) {
                        break main_loop;
                    }
                    const points_per_loop = 1;//!!!parseInt(points_per_loop_el.value);
                    for (let lp = 0; lp < points_per_loop; lp++) {
                        if (!this._running) {
                            break main_loop;
                        }
                        points = points.map(x => extrapolator(pc_dt, f, x, params));
                        update_trace();
                    }
console.log('DRAWING');//!!!
                    this._draw_data(Plotly.react);
                    await new Promise(resolve => setTimeout(resolve));  // wait for next tick
                }
            }

            static async _evaluate(expression) {
                const eval_context = {};  //!!!_create_eval_context();
                const eval_context_entries = Object.entries(eval_context);

                // create an async function with the expression as its body, and
                // with parameters being the keys of eval_context.  Then, the
                // expression will be evaluated by applying the function to the
                // corresponding values from eval_context.  Note that evaluation
                // will be performed in the global context.
                const eval_fn_params = eval_context_entries.map(([k, _]) => k);
                const eval_fn_args   = eval_context_entries.map(([_, v]) => v);
                const AsyncFunction = Object.getPrototypeOf(async()=>{}).constructor;

                // evaluate the expression:
                const extended_expression = `'use strict';\n${expression}`;
                const eval_fn = new AsyncFunction(...eval_fn_params, extended_expression);
                const eval_fn_this = this.eval_state;

                return eval_fn.apply(eval_fn_this, eval_fn_args);
            }
        }

        go_button.focus();

    </script>
</body>
</html>
